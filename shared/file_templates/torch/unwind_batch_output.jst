{{ var topLevelFields = it.schema.topLevelFields; }}
{{ var hasFixedTensor = it.schema.tensorSize > 0 ? 1 : 0; }}
{{ var topLevelSequences = it.schema.topLevelSequences; }}

    local output{{=it.depth}} = {}
    local entries = batch1[1]:size()[2]
    for s=1,entries do
        output{{=it.depth}}[s] = {}

    {{?hasFixedTensor}}
        output{{=it.depth}}[s][1] = torch.zeros(1, 1, {{=it.schema.tensorSize}})
        output{{=it.depth}}[s][1]:copy(batch{{=it.depth}}[1]:narrow(2, s, 1))
    {{?}}


    {{~ topLevelSequences:sequence:index}}
        output{{=it.depth}}[s][{{=index+1+hasFixedTensor}}] = {}
        -- Get the number of items
        local count = batch{{=it.depth}}[{{=index+1+hasFixedTensor}}][1]:size()[2]

        -- Separate out each entry
        for n = 1, count do
            local batch{{=it.depth + 1}} = {}
            for k,v in pairs(batch{{=it.depth}}) do
                -- Insert the output
                table.insert(batch{{=it.depth + 1}}, batch{{=it.depth}}[k][{{=index+1+hasFixedTensor}}][n])
            end

            {{= it.unwindBatchOutput({schema: sequence.items, unwindBatchOutput: it.unwindBatchOutput, depth: it.depth + 1}) }}

            table.insert(batch{{=it.depth}}[{{=index+1+hasFixedTensor}}], batch{{=it.depth + 1}})
        end
    {{~}}
    end